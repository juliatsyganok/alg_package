 Отчёт по лабораторной работе №3

 Тема: Алгоритмический мини-пакет (структуры данных и сортировки)

 1. Факториал и Фибоначчи

Реализованы функции:
- `factorial(n: int) -> int` - вычисление факториала итеративным методом
- `factorial_recursive(n: int) -> int` - вычисление факториала рекурсивным методом
- `fib(n: int) -> int` - вычисление числа Фибоначчи итеративным методом
- `fib_recursive(n: int) -> int` - вычисление числа Фибоначчи рекурсивным методом

Описание:
- Все функции принимают целочисленный аргумент n и возвращают целочисленный результат
- Реализована обработка граничных случаев (n = 0, n = 1)
- Добавлена проверка на отрицательные значения с выбрасыванием исключения ValueError

 2. Алгоритмы сортировки

Реализованы функции сортировки:
- `bubble_sort(arr: list[int]) -> list[int]` - сортировка пузырьком
- `quick_sort(arr: list[int]) -> list[int]` - быстрая сортировка
- `counting_sort(arr: list[int]) -> list[int]` - сортировка подсчетом
- `radix_sort(arr: list[int], base: int = 10) -> list[int]` - поразрядная сортировка
- `bucket_sort(arr: list[float], buckets: int | None = None) -> list[float]` - блочная сортировка
- `heap_sort(arr: list[int]) -> list[int]` - пирамидальная сортировка

Особенности реализации:
- Все функции возвращают новый отсортированный список
- Исходный массив не изменяется
- Для bucket_sort реализована автоматическая нормализация float значений
- Соблюдено ограничение: не используются встроенные list.sort() и sorted()

 3. Структуры данных

Класс Stack (реализация на списке):
- `__init__(self)` - инициализация стека
- `push(self, x: int) -> None` - добавление элемента в стек
- `pop(self) -> int` - извлечение элемента из стека (выбрасывает IndexError при пустом стеке)
- `is_empty(self) -> bool` - проверка на пустоту
- `__len__(self) -> int` - получение размера стека
- `min(self) -> int` - получение минимального элемента (реализовано за O(1))

Класс Queue (реализация на списке):
- `__init__(self)` - инициализация очереди
- `enqueue(self, x: int) -> None` - добавление элемента в очередь
- `dequeue(self) -> int` - извлечение элемента из очереди (выбрасывает IndexError при пустой очереди)
- `front(self) -> int` - просмотр первого элемента (выбрасывает IndexError при пустой очереди)
- `is_empty(self) -> bool` - проверка на пустоту
- `__len__(self) -> int` - получение размера очереди

 4. Генераторы массивов

Реализованы функции генерации тестовых данных:
- `rand_int_array(n: int, lo: int, hi: int, , distinct=False, seed=None) -> list[int]` - генерация случайного целочисленного массива
- `nearly_sorted(n: int, swaps: int, , seed=None) -> list[int]` - генерация почти отсортированного массива
- `many_duplicates(n: int, k_unique=5, , seed=None) -> list[int]` - генерация массива с множеством дубликатов
- `reverse_sorted(n: int) -> list[int]` - генерация обратно отсортированного массива
- `rand_float_array(n: int, lo=0.0, hi=10.0, , seed=None) -> list[float]` - генерация случайного массива float

 5. Бенчмаркинг

Реализованы функции для тестирования производительности:
- `timeit_once(func, args, kwargs) -> float` - измерение времени выполнения одной функции
- `benchmark_sorts(arrays: dict[str, list], algos: dict[str, callable]) -> dict[str, dict[str, float]]` - сравнительный анализ алгоритмов сортировки

